'''
Строки (str) — это неизменяемые последовательности символов , предназначенные для работы с текстом.
'''

#Создание строк

#разницы между ', " - нет.

#1. Использование одинарных или двойных кавычек.

s = 'hello'
s1 = "hello"

#1. использовать экранирование символов (\). ставим перед кавычками.
print("Он сказал: \"Привет\"")

#2. использовать разные кавычки
print('Он сказал: "Привет"')

#2. Использование тройных кавычек
s2 = """Это
многострочная
строка
"""
print(s2)

#3. Операция явная конкатенация (сложение\склеивание строк)
print("hello, " + "world")

#Неявная конкатенация в скобках
print(("hello, " "world"))

#4. str() - конструктор класса str
print(str(123))


#Свойства строк:

# 1. Неизменяемость. Применение любого метода возвращает новую строку.

s3 = "hello"
# TypeError: 'str' object does not support item assignment
#s3[0] = "H"
#print(s3)
s3 = s3.replace('l', 'a') #обязательно присваивать, так как получается новая строка

#2. Последовательность. len(), min(), max(), in/not in.
#max()/ min() работает по Unicode кодам. результат работы - символ

print(max(s3))
print(len(s3)) #длина строки
print('h' in s3) #оператор in/not in проверяет наличие/неналичие подстроки в строке

#3. Все строки Unicode (utf-8 по умолчанию).
print("😊 привет")

#4. Кэширование строк. Может кэшировать маленькие строки (без пробелов)

'''
Индексация и срезы
'''
#Строка - список символов (массив символов). Можно обращаться к элементам строки по индексам.

#Индексация слева направо начинается с нуля. Индексация справа налево начинается с -1.

print(s3[1], s3[-4])

s4 = "fdgsjhfogsdhfgsdj"
print(s4[7], s4[-10])

#Срезы - выделить подстроку.

'''
Срезы
s4[start:stop:step]

start - индекс начала среза (по умолчанию 0)
stop - индекс конца среза (по умолчанию конец строки). идет невключительно
step - шаг среза (по умолчанию 1)
'''
print(s4[2:5]) #шаг не указываю, так как он равен значению по умолчанию
print(s4[:3]) #fdg
print(s4[4:7]) #jhf
print(s4[8:]) #gsdhfgsdj
print(s4[::2]) #fgjfgdfsj
print(s4[::-3]) #jgdojd, когда шаг отрицательный, то, грубо говоря, позиции start и stop меняются местами
print(s4[::-1]) #реверс строки

s5 = s4[:] #копия строки

'''
ф-ия - блок кода, реализованный вне какого-то класса (отдельно)
метод - блок кода, также являющийся функцией, но реализованный внутри какого-то класса
'''

s6 = 'Hello, world! Today is 09.15.2025'
#Преобразование регистра

#1. .capitalize(). Первый символ в uppercase (верхний регистр), а все остальные символы в lowercase (нижний регистр)
print(s6.capitalize())

#2. .lower(). Все символы приводит к lowercase
print(s6.lower())

#3. .upper(). Все символы приводит к uppercase
print(s6.upper())

#4. .title(). Переводит первые буквы каждого слова в верхний регистр. 
print(s6.title())

#5. .swapcase(). Меняет регистр.
print(s6.swapcase())

#Выравнивание строки и отступы.

#6. .center(width, fillchar=' '). Центрирует строку относительно длины. Пустое место заполняет fillchar.
'''
1 параметр - длина, относительно которой центрируем
2 параметр - тот символ, которым будет заполняться пустота (необязательный. по умолчанию - ' ')
'''
print(s6.center(50, '!'))
print(s6.center(50))

#7. .ljust(width, fillchar=' '). Выравнивает слева.
'''
1 параметр - длина, относительно которой выравниваем слева
2 параметр - тот символ, которым будет заполняться пустота (необязательный. по умолчанию - ' ')
'''
print(s6.ljust(50, '!'))
print(s6.ljust(50))

#8. .rjust(width, fillchar=' '). Выравнивает справа.
'''
1 параметр - длина, относительно которой выравниваем справа
2 параметр - тот символ, которым будет заполняться пустота (необязательный. по умолчанию - ' ')
'''
print(s6.rjust(50, '!'))
print(s6.rjust(50))

#9. .zfill(width). Выравнивает справа и заполняет слева нулями.
'''
width - длина, относительно которой выравниваем справа
'''
print(s6.zfill(50))

a = '''Hello
World'''
print(len(a)) #11, потому что учитывает \n (символ перехода на новую строку)

'''
'a', 'b', 'c' -> 'abbc'
'''
print('a' + 2 * 'b' + 'c')

print('o' in 'python')

k = 'Hello, world'
print(k.lower(), k.upper())


a = '1' * 1000
a += '2345'
print(a[-4::])
